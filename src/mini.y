/* The first section of a bison file contains:
 *    1. A code section for includes and other arbitrary C code. Copied to the parser verbatim
 *    2. Definition of the yylval union
 *    3. Definition of the tokens
 *    4. Precedence directives
 *    5. The start token
 *    6. Parser options
 */

/* Code section */

%{
#include <stdio.h>
#include <stdlib.h>


#include "tree.h"

        // Reference to the line number generated by the scanner
        extern int yylineno;
        // global g_tokens, tells scanner whether to emit (print) token info to stdout
        int g_tokens;
        // Reference to the yylex function to quiet a compiler warning
        int yylex();


        // Root PROG node
        extern PROG *root;
        // Root EXP node
/*     extern EXP *expRoot; */

/* extern STMT *stmtRoot; */
        /* typedef enum {false, true} bool; */

        // The yyerror function is called on any syntax error. When using %error-verbose, this function
        // takes a single argument (a string) which contains a detailed explanation of the error.
        // Otherwise it takes no arguments and it is up to the user to format the error using a minimal
        // description provided in yytext.
        void yyerror(const char *s) {
                fprintf(stderr, "Error: (line %d) %s\n", yylineno, s);
                exit(1);
        }
        %}

/* The union directive defines the yylval union used for associating (a) terminals (tokens)
 * returned by flex with additional scanning data (such as identifier/constant values); and
 * optionally (b) non-terminals (variables in productions) with AST information if any.
 */
%union {
        char *identifier;
        char *stringval;
        int intval;
        float floatval;
        int boolval;
        struct PROG *prog;
        struct DEC *dec;
        struct STMT *stmt;
        struct EXP *exp;
        struct TYPE *type;
};

/* Token directives define the token types to be returned by the scanner (excluding character
 * tokens). Each token definition takes [optionally, a reference to the associated field in the
 * yylval union] and an identifier. Multiple tokens can be defined per directive by using a list
 * of identifiers separated by spaces.
 */


%type <prog> program
%type <dec> declarations declaration
%type <stmt> statements statement
%type <exp> expression term factor
%type <type> type

%token <intval> tINTVAL
%token <floatval> tFLOATVAL
%token <stringval> tSTRINGVAL
%token <identifier> tIDENTIFIER
%token <boolval> tTRUE tFALSE;

%token tINT tFLOAT tBOOLEAN tSTRING;
%token tREAD tPRINT;
%token tVAR;

%token tWHILE tIF tELSE;

%token tCOLON tSEMICOLON
%token tPLUS tMINUS tMULT tDIV;
%token tASSIGN
%token tLPAR tRPAR tLBRACE tRBRACE
%token tEQUALS tNOTEQUALS tAND tOR

%token tBANG

 /* Precedence directives resolve grammar ambiguities by breaking ties between shift/reduce
  * operations. Tokens are grouped into precendence levels, with lower precedence coming first
  * and then higher precedence in later directives. Tokens specified in the same directive have
  * the same precedence. Ties at the same level are broken using either %left or %right, which
  * denote left-associative and right-associative respectively.
  */

%left tOR
%left tAND
%left tEQUALS tNOTEQUALS
%left tPLUS tMINUS
%left tMULT tDIV
%precedence tUMINUS
%left tBANG

 /* Start token (by default if this is missing it takes the first production */
%start program

 /* Generate the yylloc structure used for storing line numbers with tokens */
%locations
 /* Generate detailed error messages */
%error-verbose

 /* The second section of a bison file contains the productions. Note that rules with the
  * same LHS may be joined together and separated with a pipe.
  */
%%

program:
declarations statements { root = makePROG($1, $2); }
;

declarations:
%empty { $$ = NULL; }
| declaration declarations { $$ = $1; $$->nextDec = $2; }
;

declaration:
tVAR tIDENTIFIER tCOLON type tASSIGN expression tSEMICOLON { $$ = makeDEC($4, $2, $6); }
;

statements:
%empty { $$ = NULL; }
| statement statements { $$ = $1; $$->nextStmt = $2; }
;

statement:
tIDENTIFIER tASSIGN expression tSEMICOLON { $$ = makeSTMT_assign($1, $3);}
| tIF expression tLBRACE statements tRBRACE {$$ = makeSTMT_if($2, $4);}
| tIF expression tLBRACE statements tRBRACE tELSE tLBRACE statements tRBRACE {$$ = makeSTMT_ifelse($2, $4, $8);}
| tWHILE expression tLBRACE statements tRBRACE {$$ = makeSTMT_while($2, $4);}
| tPRINT expression tSEMICOLON {$$ = makeSTMT_print($2);}
| tREAD tIDENTIFIER tSEMICOLON {$$ = makeSTMT_read($2);}
;

expression :
expression tPLUS expression { $$ = makeEXP_binary(k_expressionKindAddition, $1, $3); }
| expression tMINUS expression { $$ = makeEXP_binary(k_expressionKindSubtraction, $1, $3); }
| expression tEQUALS expression { $$ = makeEXP_binary(k_expressionKindEquals, $1, $3); }
| expression tNOTEQUALS expression { $$ = makeEXP_binary(k_expressionKindNotEquals, $1, $3); }
| expression tAND expression { $$ = makeEXP_binary(k_expressionKindAnd, $1, $3); }
| expression tOR expression { $$ = makeEXP_binary(k_expressionKindOr, $1, $3); }
| tMINUS expression %prec tUMINUS { $$ = makeEXP_unary(k_expressionKindUMinus, $2); }
| tBANG expression { $$ = makeEXP_unary(k_expressionKindBang, $2); }
| term { $$ = $1; }
;

term :
term tMULT factor { $$ = makeEXP_binary(k_expressionKindMultiplication, $1, $3); }
| term tDIV factor { $$ = makeEXP_binary(k_expressionKindDivision, $1, $3); }
| factor { $$ = $1; }
;

factor :
tLPAR expression tRPAR { $$ = $2; }
| tIDENTIFIER { $$ = makeEXP_identifier($1); }
| tINTVAL     { $$ = makeEXP_intval($1); }
| tFLOATVAL     {  $$ = makeEXP_floatval($1); }
| tSTRINGVAL     { $$ = makeEXP_stringval($1); }
| tTRUE {  $$ = makeEXP_boolval(1); }
| tFALSE { $$ = makeEXP_boolval(0); }
;

type :
tFLOAT {  $$ = makeTYPE_float(); }
| tINT {  $$ = makeTYPE_int(); }
| tSTRING { $$ = makeTYPE_string(); }
| tBOOLEAN { $$ = makeTYPE_bool(); }
;

%%

        /* | tMINUS expression %prec tUMINUS {} */
        /* declarations statements */
        /* expression { root = $1; } */
/* | declarations declaration { $$ = $2; $$ = insertDEC($1, $2); ;} */
/* | statements statement { $$ = insertSTMT($1, $2); } */
